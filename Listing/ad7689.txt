; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ad7689.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ad7689.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\FATFS -I..\IAP -IE:\Keil_v5\ARM\RV31\INC -IE:\Keil_v5\ARM\CMSIS\Include -IE:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\ad7689.crf --no_multibyte_chars ..\drive\AD7689.c]
                          THUMB

                          AREA ||i.AD7689_Delay||, CODE, READONLY, ALIGN=1

                  AD7689_Delay PROC
;;;241    /************************************************************************/
;;;242    void AD7689_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;243    {
;;;244    	vu16 count ;
;;;245      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
000006  9000              STR      r0,[sp,#0]
000008  e003              B        |L1.18|
                  |L1.10|
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L1.18|
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  2800              CMP      r0,#0
000018  d1f7              BNE      |L1.10|
;;;246    }
00001a  bd08              POP      {r3,pc}
;;;247    void AD7689_Delay1(void)
                          ENDP


                          AREA ||i.AD7689_Delay1||, CODE, READONLY, ALIGN=1

                  AD7689_Delay1 PROC
;;;246    }
;;;247    void AD7689_Delay1(void)
000000  b508              PUSH     {r3,lr}
;;;248    {
;;;249    	vu16 count ;
;;;250      for(count = 3000; count != 0; count--);
000002  f64030b8          MOV      r0,#0xbb8
000006  9000              STR      r0,[sp,#0]
000008  e003              B        |L2.18|
                  |L2.10|
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L2.18|
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  2800              CMP      r0,#0
000018  d1f7              BNE      |L2.10|
;;;251    }
00001a  bd08              POP      {r3,pc}
;;;252    void AD7689_Scan_CH(void)
                          ENDP


                          AREA ||i.AD7689_InitializeSPI1||, CODE, READONLY, ALIGN=2

                  AD7689_InitializeSPI1 PROC
;;;33     void Bubble_sort(vu16 *D_temp,vu8 num);
;;;34     void AD7689_InitializeSPI1(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;35     {
000004  b088              SUB      sp,sp,#0x20
;;;36     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;37       SPI_InitTypeDef  SPI_InitStructure;
;;;38     	
;;;39     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
000006  2101              MOVS     r1,#1
000008  0308              LSLS     r0,r1,#12
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;40     	
;;;41     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00000e  2702              MOVS     r7,#2
000010  f88d701d          STRB     r7,[sp,#0x1d]
;;;42     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000014  2601              MOVS     r6,#1
000016  f88d601c          STRB     r6,[sp,#0x1c]
;;;43     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001a  2400              MOVS     r4,#0
00001c  f88d401e          STRB     r4,[sp,#0x1e]
;;;44     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;//inv
000020  2040              MOVS     r0,#0x40
000022  9006              STR      r0,[sp,#0x18]
;;;45     	GPIO_Init(GPIOB, &GPIO_InitStructure);//
000024  f8df80a0          LDR      r8,|L3.200|
000028  a906              ADD      r1,sp,#0x18
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       GPIO_Init
;;;46     	
;;;47       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
000030  2538              MOVS     r5,#0x38
000032  9506              STR      r5,[sp,#0x18]
;;;48       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000034  f88d701c          STRB     r7,[sp,#0x1c]
;;;49       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000038  f88d401e          STRB     r4,[sp,#0x1e]
;;;50       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
00003c  2003              MOVS     r0,#3
00003e  f88d001d          STRB     r0,[sp,#0x1d]
;;;51       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
000042  f88d601f          STRB     r6,[sp,#0x1f]
;;;52       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000046  a906              ADD      r1,sp,#0x18
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       GPIO_Init
;;;53     
;;;54       GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); //PCB3复用为 SPI1
00004e  2205              MOVS     r2,#5
000050  2103              MOVS     r1,#3
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;55     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); //PBB4复用为 SPI1
000058  2205              MOVS     r2,#5
00005a  2104              MOVS     r1,#4
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;56     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); //PB5复用为 SPI1
000062  2205              MOVS     r2,#5
000064  4611              MOV      r1,r2
000066  4640              MOV      r0,r8
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;57     	AD7689_CNV_1;
00006c  2140              MOVS     r1,#0x40
00006e  4640              MOV      r0,r8
000070  f7fffffe          BL       GPIO_SetBits
;;;58     	AD7689_Delay();
000074  f7fffffe          BL       AD7689_Delay
;;;59     	AD7689_CNV_0;
000078  2140              MOVS     r1,#0x40
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       GPIO_ResetBits
;;;60     	//这里只针对SPI口初始化
;;;61       SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000080  f8ad4004          STRH     r4,[sp,#4]
;;;62     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000084  f44f7082          MOV      r0,#0x104
000088  f8ad0006          STRH     r0,[sp,#6]
;;;63     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;		//设置SPI的数据大小:SPI发送接收16位帧结构
00008c  02f0              LSLS     r0,r6,#11
00008e  f8ad0008          STRH     r0,[sp,#8]
;;;64     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
000092  f8ad400a          STRH     r4,[sp,#0xa]
;;;65     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000096  f8ad400c          STRH     r4,[sp,#0xc]
;;;66     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
00009a  1080              ASRS     r0,r0,#2
00009c  f8ad000e          STRH     r0,[sp,#0xe]
;;;67     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
0000a0  f8ad5010          STRH     r5,[sp,#0x10]
;;;68     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
0000a4  f8ad4012          STRH     r4,[sp,#0x12]
;;;69     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
0000a8  2007              MOVS     r0,#7
0000aa  f8ad0014          STRH     r0,[sp,#0x14]
;;;70     	SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000ae  4c07              LDR      r4,|L3.204|
0000b0  a901              ADD      r1,sp,#4
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       SPI_Init
;;;71     	
;;;72     	SPI_Cmd(SPI1, ENABLE); //使能SPI外设*/
0000b8  2101              MOVS     r1,#1
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       SPI_Cmd
;;;73     }
0000c0  b008              ADD      sp,sp,#0x20
0000c2  e8bd81f0          POP      {r4-r8,pc}
;;;74     
                          ENDP

0000c6  0000              DCW      0x0000
                  |L3.200|
                          DCD      0x40020400
                  |L3.204|
                          DCD      0x40013000

                          AREA ||i.AD7689_Scan_CH||, CODE, READONLY, ALIGN=2

                  AD7689_Scan_CH PROC
;;;251    }
;;;252    void AD7689_Scan_CH(void)
000000  b570              PUSH     {r4-r6,lr}
;;;253    {
000002  b088              SUB      sp,sp,#0x20
;;;254    	static vu8 I_cont,I1_cont,V_cont,R_cont,V1_cont;
;;;255    	vu8 i,f;
;;;256    	vu32 sum1;
;;;257    	vu16 var_chI,var_chI1,var_chV,var_chV1,var_chR;
;;;258    	for(i=0;i<8;i++)
000004  2500              MOVS     r5,#0
000006  9507              STR      r5,[sp,#0x1c]
;;;259    	{
;;;260    		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
000008  4c6a              LDR      r4,|L4.436|
00000a  e016              B        |L4.58|
                  |L4.12|
00000c  f89d101c          LDRB     r1,[sp,#0x1c]
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       SPI_AD7689_Read
000016  f89d101c          LDRB     r1,[sp,#0x1c]
00001a  f8240011          STRH     r0,[r4,r1,LSL #1]
;;;261    		var_chV=AD7689_Buffer[2];
00001e  88a0              LDRH     r0,[r4,#4]  ; AD7689_Buffer
000020  9002              STR      r0,[sp,#8]
;;;262    		var_chI=AD7689_Buffer[3];
000022  88e0              LDRH     r0,[r4,#6]  ; AD7689_Buffer
000024  9004              STR      r0,[sp,#0x10]
;;;263    		var_chI1=AD7689_Buffer[5];
000026  8960              LDRH     r0,[r4,#0xa]  ; AD7689_Buffer
000028  9003              STR      r0,[sp,#0xc]
;;;264    		var_chV1=AD7689_Buffer[6];
00002a  89a0              LDRH     r0,[r4,#0xc]  ; AD7689_Buffer
00002c  9001              STR      r0,[sp,#4]
;;;265    		var_chR=AD7689_Buffer[7];
00002e  89e0              LDRH     r0,[r4,#0xe]  ; AD7689_Buffer
000030  9000              STR      r0,[sp,#0]
000032  f89d001c          LDRB     r0,[sp,#0x1c]         ;258
000036  1c40              ADDS     r0,r0,#1              ;258
000038  9007              STR      r0,[sp,#0x1c]         ;258
                  |L4.58|
00003a  f89d001c          LDRB     r0,[sp,#0x1c]         ;258
00003e  2808              CMP      r0,#8                 ;258
000040  d3e4              BCC      |L4.12|
;;;266    	}
;;;267    	Ad7689_Fit_Imon[I_cont++]=var_chI;
000042  f8bd3010          LDRH     r3,[sp,#0x10]
000046  4a5c              LDR      r2,|L4.440|
000048  7810              LDRB     r0,[r2,#0]  ; I_cont
00004a  1c41              ADDS     r1,r0,#1
00004c  7011              STRB     r1,[r2,#0]
00004e  0041              LSLS     r1,r0,#1
000050  4858              LDR      r0,|L4.436|
000052  3010              ADDS     r0,r0,#0x10
000054  5243              STRH     r3,[r0,r1]
;;;268    	if(I_cont==5)
000056  7811              LDRB     r1,[r2,#0]  ; I_cont
000058  2905              CMP      r1,#5
00005a  d118              BNE      |L4.142|
;;;269    	{
;;;270    		I_cont=0;
00005c  7015              STRB     r5,[r2,#0]
;;;271    		sum1=0;
00005e  9505              STR      r5,[sp,#0x14]
;;;272    		for(f=0;f<5;f++)
000060  9506              STR      r5,[sp,#0x18]
000062  e00a              B        |L4.122|
                  |L4.100|
;;;273    		{
;;;274    			sum1 +=Ad7689_Fit_Imon[f];
000064  f89d1018          LDRB     r1,[sp,#0x18]
000068  f8301011          LDRH     r1,[r0,r1,LSL #1]
00006c  9b05              LDR      r3,[sp,#0x14]
00006e  4419              ADD      r1,r1,r3
000070  9105              STR      r1,[sp,#0x14]
000072  f89d1018          LDRB     r1,[sp,#0x18]         ;272
000076  1c49              ADDS     r1,r1,#1              ;272
000078  9106              STR      r1,[sp,#0x18]         ;272
                  |L4.122|
00007a  f89d1018          LDRB     r1,[sp,#0x18]         ;272
00007e  2905              CMP      r1,#5                 ;272
000080  d3f0              BCC      |L4.100|
;;;275    		}
;;;276    		Imon1_value=sum1/5;//璐杞界垫
000082  9805              LDR      r0,[sp,#0x14]
000084  2105              MOVS     r1,#5
000086  fbb0f0f1          UDIV     r0,r0,r1
00008a  494c              LDR      r1,|L4.444|
00008c  6008              STR      r0,[r1,#0]  ; Imon1_value
                  |L4.142|
;;;277    	}
;;;278    	
;;;279    	Ad7689_Fit_Imon1[I1_cont++]=var_chI1;
00008e  f8bd300c          LDRH     r3,[sp,#0xc]
000092  7850              LDRB     r0,[r2,#1]  ; I1_cont
000094  1c41              ADDS     r1,r0,#1
000096  7051              STRB     r1,[r2,#1]
000098  0041              LSLS     r1,r0,#1
00009a  4846              LDR      r0,|L4.436|
00009c  3088              ADDS     r0,r0,#0x88
00009e  5243              STRH     r3,[r0,r1]
;;;280    	if(I1_cont==30)
0000a0  7851              LDRB     r1,[r2,#1]  ; I1_cont
;;;281    	{
;;;282    		I1_cont=0;
;;;283    		sum1=0;
;;;284    		for(f=0;f<30;f++)
;;;285    		{
;;;286    			sum1 +=Ad7689_Fit_Imon1[f];
;;;287    		}
;;;288    		Imon_value=sum1/30;//垫垫
0000a2  231e              MOVS     r3,#0x1e
0000a4  291e              CMP      r1,#0x1e              ;280
0000a6  d117              BNE      |L4.216|
0000a8  7055              STRB     r5,[r2,#1]            ;282
0000aa  9505              STR      r5,[sp,#0x14]         ;283
0000ac  9506              STR      r5,[sp,#0x18]         ;284
0000ae  e00a              B        |L4.198|
                  |L4.176|
0000b0  f89d1018          LDRB     r1,[sp,#0x18]         ;286
0000b4  f8301011          LDRH     r1,[r0,r1,LSL #1]     ;286
0000b8  9c05              LDR      r4,[sp,#0x14]         ;286
0000ba  4421              ADD      r1,r1,r4              ;286
0000bc  9105              STR      r1,[sp,#0x14]         ;286
0000be  f89d1018          LDRB     r1,[sp,#0x18]         ;284
0000c2  1c49              ADDS     r1,r1,#1              ;284
0000c4  9106              STR      r1,[sp,#0x18]         ;284
                  |L4.198|
0000c6  f89d1018          LDRB     r1,[sp,#0x18]         ;284
0000ca  291e              CMP      r1,#0x1e              ;284
0000cc  d3f0              BCC      |L4.176|
0000ce  9805              LDR      r0,[sp,#0x14]
0000d0  493b              LDR      r1,|L4.448|
0000d2  fbb0f0f3          UDIV     r0,r0,r3
0000d6  8008              STRH     r0,[r1,#0]
                  |L4.216|
;;;289    	}
;;;290    	
;;;291    	Ad7689_Fit_PVmon[V1_cont++]=var_chV1;
0000d8  f8bd4004          LDRH     r4,[sp,#4]
0000dc  7910              LDRB     r0,[r2,#4]  ; V1_cont
0000de  1c41              ADDS     r1,r0,#1
0000e0  7111              STRB     r1,[r2,#4]
0000e2  0041              LSLS     r1,r0,#1
0000e4  4837              LDR      r0,|L4.452|
0000e6  5244              STRH     r4,[r0,r1]
;;;292    	if(V1_cont==10)
0000e8  7911              LDRB     r1,[r2,#4]  ; V1_cont
;;;293    	{
;;;294    		V1_cont=0;
;;;295    		sum1=0;
;;;296    		for(f=0;f<10;f++)
;;;297    		{
;;;298    			sum1 +=Ad7689_Fit_PVmon[f];
;;;299    		}
;;;300    		Vmon_value=sum1/10;//垫靛
0000ea  240a              MOVS     r4,#0xa
0000ec  290a              CMP      r1,#0xa               ;292
0000ee  d117              BNE      |L4.288|
0000f0  7115              STRB     r5,[r2,#4]            ;294
0000f2  9505              STR      r5,[sp,#0x14]         ;295
0000f4  9506              STR      r5,[sp,#0x18]         ;296
0000f6  e00a              B        |L4.270|
                  |L4.248|
0000f8  f89d1018          LDRB     r1,[sp,#0x18]         ;298
0000fc  f8301011          LDRH     r1,[r0,r1,LSL #1]     ;298
000100  9e05              LDR      r6,[sp,#0x14]         ;298
000102  4431              ADD      r1,r1,r6              ;298
000104  9105              STR      r1,[sp,#0x14]         ;298
000106  f89d1018          LDRB     r1,[sp,#0x18]         ;296
00010a  1c49              ADDS     r1,r1,#1              ;296
00010c  9106              STR      r1,[sp,#0x18]         ;296
                  |L4.270|
00010e  f89d1018          LDRB     r1,[sp,#0x18]         ;296
000112  290a              CMP      r1,#0xa               ;296
000114  d3f0              BCC      |L4.248|
000116  9805              LDR      r0,[sp,#0x14]
000118  492b              LDR      r1,|L4.456|
00011a  fbb0f0f4          UDIV     r0,r0,r4
00011e  8008              STRH     r0,[r1,#0]
                  |L4.288|
;;;301    	}
;;;302    	
;;;303    	Ad7689_Fit_Vmon[V_cont++]=var_chV;
000120  f8bd6008          LDRH     r6,[sp,#8]
000124  7890              LDRB     r0,[r2,#2]  ; V_cont
000126  1c41              ADDS     r1,r0,#1
000128  7091              STRB     r1,[r2,#2]
00012a  0041              LSLS     r1,r0,#1
00012c  4821              LDR      r0,|L4.436|
00012e  30ec              ADDS     r0,r0,#0xec
000130  5246              STRH     r6,[r0,r1]
;;;304    	if(V_cont==10)
000132  7891              LDRB     r1,[r2,#2]  ; V_cont
000134  290a              CMP      r1,#0xa
000136  d100              BNE      |L4.314|
;;;305    	{
;;;306    		V_cont=0;
000138  7095              STRB     r5,[r2,#2]
                  |L4.314|
;;;307    		
;;;308    	}
;;;309    	sum1=0;
00013a  9505              STR      r5,[sp,#0x14]
;;;310    //		Bubble_sort( Ad7689_Fit_Vmon,100);//排序从大到小
;;;311    		for(f=0;f<10;f++)
00013c  9506              STR      r5,[sp,#0x18]
00013e  e00a              B        |L4.342|
                  |L4.320|
;;;312    		{
;;;313    			sum1 +=Ad7689_Fit_Vmon[f];
000140  f89d1018          LDRB     r1,[sp,#0x18]
000144  f8301011          LDRH     r1,[r0,r1,LSL #1]
000148  9e05              LDR      r6,[sp,#0x14]
00014a  4431              ADD      r1,r1,r6
00014c  9105              STR      r1,[sp,#0x14]
00014e  f89d1018          LDRB     r1,[sp,#0x18]         ;311
000152  1c49              ADDS     r1,r1,#1              ;311
000154  9106              STR      r1,[sp,#0x18]         ;311
                  |L4.342|
000156  f89d1018          LDRB     r1,[sp,#0x18]         ;311
00015a  290a              CMP      r1,#0xa               ;311
00015c  d3f0              BCC      |L4.320|
;;;314    		}
;;;315    		Vmon1_value=sum1/10;//璐杞界靛
00015e  9805              LDR      r0,[sp,#0x14]
000160  491a              LDR      r1,|L4.460|
000162  fbb0f0f4          UDIV     r0,r0,r4
000166  6008              STR      r0,[r1,#0]  ; Vmon1_value
;;;316    
;;;317    	Ad7689_Fit_Rmon[R_cont++]=var_chR;
000168  f8bd4000          LDRH     r4,[sp,#0]
00016c  78d0              LDRB     r0,[r2,#3]  ; R_cont
00016e  1c41              ADDS     r1,r0,#1
000170  70d1              STRB     r1,[r2,#3]
000172  0041              LSLS     r1,r0,#1
000174  4813              LDR      r0,|L4.452|
000176  383c              SUBS     r0,r0,#0x3c
000178  5244              STRH     r4,[r0,r1]
;;;318    	if(R_cont==30)
00017a  78d1              LDRB     r1,[r2,#3]  ; R_cont
00017c  291e              CMP      r1,#0x1e
00017e  d117              BNE      |L4.432|
;;;319    	{
;;;320    		R_cont=0;
000180  70d5              STRB     r5,[r2,#3]
;;;321    		sum1=0;
000182  9505              STR      r5,[sp,#0x14]
;;;322    		for(f=0;f<30;f++)
000184  9506              STR      r5,[sp,#0x18]
000186  e00a              B        |L4.414|
                  |L4.392|
;;;323    		{
;;;324    			sum1 +=Ad7689_Fit_Rmon[f];
000188  f89d1018          LDRB     r1,[sp,#0x18]
00018c  f8301011          LDRH     r1,[r0,r1,LSL #1]
000190  9a05              LDR      r2,[sp,#0x14]
000192  4411              ADD      r1,r1,r2
000194  9105              STR      r1,[sp,#0x14]
000196  f89d1018          LDRB     r1,[sp,#0x18]         ;322
00019a  1c49              ADDS     r1,r1,#1              ;322
00019c  9106              STR      r1,[sp,#0x18]         ;322
                  |L4.414|
00019e  f89d1018          LDRB     r1,[sp,#0x18]         ;322
0001a2  291e              CMP      r1,#0x1e              ;322
0001a4  d3f0              BCC      |L4.392|
;;;325    		}
;;;326    		Rmon_value=sum1/30;//
0001a6  9805              LDR      r0,[sp,#0x14]
0001a8  4909              LDR      r1,|L4.464|
0001aa  fbb0f0f3          UDIV     r0,r0,r3
0001ae  8008              STRH     r0,[r1,#0]
                  |L4.432|
;;;327    	}
;;;328    }
0001b0  b008              ADD      sp,sp,#0x20
0001b2  bd70              POP      {r4-r6,pc}
;;;329    
                          ENDP

                  |L4.436|
                          DCD      ||.bss||
                  |L4.440|
                          DCD      ||.data||
                  |L4.444|
                          DCD      Imon1_value
                  |L4.448|
                          DCD      Imon_value
                  |L4.452|
                          DCD      ||.bss||+0x1f0
                  |L4.456|
                          DCD      Vmon_value
                  |L4.460|
                          DCD      Vmon1_value
                  |L4.464|
                          DCD      Rmon_value

                          AREA ||i.AD7689_TransferByte||, CODE, READONLY, ALIGN=2

                  AD7689_TransferByte PROC
;;;222    /************************************************************************/
;;;223    vu16 AD7689_TransferByte(vu16 uiTxData)
000000  b511              PUSH     {r0,r4,lr}
;;;224    {
000002  b081              SUB      sp,sp,#4
;;;225    	vu16 uiRxData;
;;;226    	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  4c0c              LDR      r4,|L5.56|
                  |L5.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L5.6|
;;;227    //	dma_send(uiTxData,1);
;;;228    	SPI_I2S_SendData(SPI1,uiTxData);
000012  f8bd1004          LDRH     r1,[sp,#4]
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_I2S_SendData
                  |L5.28|
;;;229    	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L5.28|
;;;230    //	dma_rec(uiRxData,1);
;;;231    	uiRxData = SPI_I2S_ReceiveData(SPI1);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  9000              STR      r0,[sp,#0]
;;;232    	return uiRxData;
000030  f8bd0000          LDRH     r0,[sp,#0]
;;;233    }
000034  bd1c              POP      {r2-r4,pc}
;;;234    /************************************************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40013000

                          AREA ||i.Bubble_sort||, CODE, READONLY, ALIGN=1

                  Bubble_sort PROC
;;;332     */
;;;333    void Bubble_sort(vu16 *D_temp,vu8 num)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;334    {
;;;335    	unsigned int _temp;
;;;336    	unsigned char m,n;
;;;337    	for(m=0;m<num;m++)
000002  2200              MOVS     r2,#0
000004  e017              B        |L6.54|
                  |L6.6|
;;;338    	{
;;;339    		for(n=m;n<num;n++)
000006  4611              MOV      r1,r2
000008  e00f              B        |L6.42|
                  |L6.10|
;;;340    		{
;;;341    			if(D_temp[n]>D_temp[m])//最大的值放在第一位
00000a  f8303011          LDRH     r3,[r0,r1,LSL #1]
00000e  f8304012          LDRH     r4,[r0,r2,LSL #1]
000012  42a3              CMP      r3,r4
000014  d907              BLS      |L6.38|
;;;342    			{
;;;343    				_temp = D_temp[m];
000016  f8303012          LDRH     r3,[r0,r2,LSL #1]
;;;344    				D_temp[m] =D_temp[n];
00001a  f8304011          LDRH     r4,[r0,r1,LSL #1]
00001e  f8204012          STRH     r4,[r0,r2,LSL #1]
;;;345    				D_temp[n]=_temp;		
000022  f8203011          STRH     r3,[r0,r1,LSL #1]
                  |L6.38|
000026  1c49              ADDS     r1,r1,#1              ;339
000028  b2c9              UXTB     r1,r1                 ;339
                  |L6.42|
00002a  f89d3004          LDRB     r3,[sp,#4]            ;339
00002e  4299              CMP      r1,r3                 ;339
000030  d3eb              BCC      |L6.10|
000032  1c52              ADDS     r2,r2,#1              ;337
000034  b2d2              UXTB     r2,r2                 ;337
                  |L6.54|
000036  f89d1004          LDRB     r1,[sp,#4]            ;337
00003a  428a              CMP      r2,r1                 ;337
00003c  d3e3              BCC      |L6.6|
;;;346    			}
;;;347    		}	
;;;348    	}
;;;349    }
00003e  bd1c              POP      {r2-r4,pc}
                          ENDP


                          AREA ||i.MYDMA_Config||, CODE, READONLY, ALIGN=2

                  MYDMA_Config PROC
;;;82     //ndtr:数据传输量  
;;;83     void MYDMA_Config(void)
000000  b510              PUSH     {r4,lr}
;;;84     { 
000002  b090              SUB      sp,sp,#0x40
;;;85      
;;;86     	DMA_InitTypeDef  DMA_InitStructure;
;;;87     	
;;;88     //	if((u32)DMA_Streamx>(u32)DMA2)//得到当前stream是属于DMA2还是DMA1
;;;89     //	{
;;;90     	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,ENABLE);//DMA2时钟使能 
000004  2101              MOVS     r1,#1
000006  0588              LSLS     r0,r1,#22
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;91     		
;;;92     //	}else 
;;;93     //	{
;;;94     //	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1,ENABLE);//DMA1时钟使能 
;;;95     //	}
;;;96       DMA_DeInit(DMA2_Stream0);
00000c  4c17              LDR      r4,|L7.108|
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       DMA_DeInit
                  |L7.20|
;;;97     	
;;;98     	while (DMA_GetCmdStatus(DMA2_Stream0) != DISABLE){}//等待DMA可配置 
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       DMA_GetCmdStatus
00001a  2800              CMP      r0,#0
00001c  d1fa              BNE      |L7.20|
;;;99     	
;;;100      /* 配置 DMA Stream */
;;;101      DMA_InitStructure.DMA_Channel = DMA_Channel_3;  //通道选择
00001e  f04f60c0          MOV      r0,#0x6000000
000022  9001              STR      r0,[sp,#4]
;;;102      DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&SPI1->DR;//DMA外设地址
000024  4812              LDR      r0,|L7.112|
000026  9002              STR      r0,[sp,#8]
;;;103      DMA_InitStructure.DMA_Memory0BaseAddr = (u32)AD7689_Buffer;//DMA 存储器0地址
000028  4812              LDR      r0,|L7.116|
00002a  9003              STR      r0,[sp,#0xc]
;;;104      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;//存储器到外设模式
00002c  2040              MOVS     r0,#0x40
00002e  9004              STR      r0,[sp,#0x10]
;;;105      DMA_InitStructure.DMA_BufferSize = 8;//数据传输量 
000030  2008              MOVS     r0,#8
000032  9005              STR      r0,[sp,#0x14]
;;;106      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设非增量模式
000034  2000              MOVS     r0,#0
000036  9006              STR      r0,[sp,#0x18]
;;;107      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储器增量模式
000038  f44f6180          MOV      r1,#0x400
00003c  9107              STR      r1,[sp,#0x1c]
;;;108      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据长度:8位
00003e  9008              STR      r0,[sp,#0x20]
;;;109      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;//存储器数据长度:8位
000040  9009              STR      r0,[sp,#0x24]
;;;110      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;// 使用普通模式 
000042  900a              STR      r0,[sp,#0x28]
;;;111      DMA_InitStructure.DMA_Priority = DMA_Priority_High;//高优先级
000044  01c9              LSLS     r1,r1,#7
000046  910b              STR      r1,[sp,#0x2c]
;;;112      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
000048  900c              STR      r0,[sp,#0x30]
;;;113      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
00004a  2103              MOVS     r1,#3
00004c  910d              STR      r1,[sp,#0x34]
;;;114      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;//存储器突发单次传输
00004e  900e              STR      r0,[sp,#0x38]
;;;115      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;//外设突发单次传输
000050  900f              STR      r0,[sp,#0x3c]
;;;116      DMA_Init(DMA2_Stream0, &DMA_InitStructure);//初始化DMA Stream
000052  a901              ADD      r1,sp,#4
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       DMA_Init
;;;117    	
;;;118    //	DMA_DeInit(DMA2_Stream3);	
;;;119    //	while (DMA_GetCmdStatus(DMA2_Stream3) != DISABLE){}//等待DMA可配置 
;;;120    ////	DMA_InitStructure.DMA_Priority = DMA_Priority_High;//高优先级
;;;121    ////	DMA_InitStructure.DMA_Channel = DMA_Channel_3;  //通道选择
;;;122    ////	DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;//存储器到外设模式
;;;123    ////	DMA_Init(DMA2_Stream3, &DMA_InitStructure);//初始化DMA Stream
;;;124    //		
;;;125    //  DMA_InitStructure.DMA_Channel = DMA_Channel_3;  //通道选择
;;;126    //  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&SPI1->DR;//DMA外设地址
;;;127    //  DMA_InitStructure.DMA_Memory0BaseAddr = (u32)0;//DMA 存储器0地址
;;;128    //  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;//存储器到外设模式
;;;129    //  DMA_InitStructure.DMA_BufferSize = 0;//数据传输量 
;;;130    //  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设非增量模式
;;;131    //  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储器增量模式
;;;132    //  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据长度:8位
;;;133    //  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;//存储器数据长度:8位
;;;134    //  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;// 使用普通模式 
;;;135    //  DMA_InitStructure.DMA_Priority = DMA_Priority_High;//高优先级
;;;136    //  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
;;;137    //  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
;;;138    //  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;//存储器突发单次传输
;;;139    //  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;//外设突发单次传输
;;;140    //  DMA_Init(DMA2_Stream3, &DMA_InitStructure);//初始化DMA Stream
;;;141    		
;;;142    	SPI_I2S_DMACmd(SPI1,SPI_I2S_DMAReq_Rx,ENABLE);
00005a  4805              LDR      r0,|L7.112|
00005c  2201              MOVS     r2,#1
00005e  4611              MOV      r1,r2
000060  380c              SUBS     r0,r0,#0xc
000062  f7fffffe          BL       SPI_I2S_DMACmd
;;;143    //	SPI_I2S_DMACmd(SPI1,SPI_I2S_DMAReq_Tx,ENABLE);
;;;144    }
000066  b010              ADD      sp,sp,#0x40
000068  bd10              POP      {r4,pc}
;;;145    
                          ENDP

00006a  0000              DCW      0x0000
                  |L7.108|
                          DCD      0x40026410
                  |L7.112|
                          DCD      0x4001300c
                  |L7.116|
                          DCD      ||.bss||

                          AREA ||i.MYDMA_Enable||, CODE, READONLY, ALIGN=2

                  MYDMA_Enable PROC
;;;148    //ndtr:数据传输量  
;;;149    void MYDMA_Enable(DMA_Stream_TypeDef *DMA_Streamx,u16 ndtr)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;151    	SPI_InitTypeDef  SPI_InitStructure;
;;;152    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_RxOnly;
000008  f44f6080          MOV      r0,#0x400
00000c  f8ad0004          STRH     r0,[sp,#4]
;;;153    	SPI_Init(SPI1, &SPI_InitStructure);//只读
000010  4c0f              LDR      r4,|L8.80|
000012  a901              ADD      r1,sp,#4
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_Init
;;;154    	DMA_Cmd(DMA_Streamx, DISABLE);                      //关闭DMA传输 
00001a  2100              MOVS     r1,#0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       DMA_Cmd
                  |L8.34|
;;;155    	
;;;156    	while (DMA_GetCmdStatus(DMA_Streamx) != DISABLE){}	//确保DMA可以被设置  
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DMA_GetCmdStatus
000028  2800              CMP      r0,#0
00002a  d1fa              BNE      |L8.34|
;;;157    		
;;;158    	DMA_SetCurrDataCounter(DMA_Streamx,ndtr);          //数据传输量  
00002c  4631              MOV      r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       DMA_SetCurrDataCounter
;;;159     
;;;160    	DMA_Cmd(DMA_Streamx, ENABLE);                      //开启DMA传输
000034  2101              MOVS     r1,#1
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       DMA_Cmd
;;;161    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
00003c  2000              MOVS     r0,#0
00003e  f8ad0004          STRH     r0,[sp,#4]
;;;162    	SPI_Init(SPI1, &SPI_InitStructure);//恢复双全工
000042  a901              ADD      r1,sp,#4
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Init
;;;163    	
;;;164    }	  
00004a  b006              ADD      sp,sp,#0x18
00004c  bd70              POP      {r4-r6,pc}
;;;165    //DMA发送
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0x40013000

                          AREA ||i.SPI_AD7689_Read||, CODE, READONLY, ALIGN=2

                  SPI_AD7689_Read PROC
;;;199    
;;;200    vu16 SPI_AD7689_Read(vu16 AD7689_CFG, vu16 AD7689_INx)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;201    {
000002  b082              SUB      sp,sp,#8
;;;202    	vu16 AD7689_Config=0;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;203    	vu16 AD7689_Data;
;;;204    	vu8 i;
;;;205    	AD7689_Config = AD7689_CFG<<13|AD7689_INCC<<10|AD7689_INx<<7|AD7689_BW<<6|AD7689_REF<<3|AD7689_SEQ<<1|AD7689_RB;//写入配置参数
000008  f8bd0008          LDRH     r0,[sp,#8]
00000c  f8bd100c          LDRH     r1,[sp,#0xc]
000010  0340              LSLS     r0,r0,#13
000012  ea4010c1          ORR      r0,r0,r1,LSL #7
000016  f6414159          MOV      r1,#0x1c59
00001a  4308              ORRS     r0,r0,r1
00001c  9001              STR      r0,[sp,#4]
;;;206    	AD7689_Config <<=2;
00001e  f8bd0004          LDRH     r0,[sp,#4]
000022  f64f71ff          MOV      r1,#0xffff
000026  ea010080          AND      r0,r1,r0,LSL #2
00002a  9001              STR      r0,[sp,#4]
;;;207    	AD7689_CNV_0;
00002c  4c09              LDR      r4,|L9.84|
00002e  2140              MOVS     r1,#0x40
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_ResetBits
;;;208    	AD7689_Data=AD7689_TransferByte(AD7689_Config);
000036  f8bd0004          LDRH     r0,[sp,#4]
00003a  f7fffffe          BL       AD7689_TransferByte
00003e  9000              STR      r0,[sp,#0]
;;;209    	AD7689_CNV_1;
000040  2140              MOVS     r1,#0x40
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       GPIO_SetBits
;;;210    	AD7689_Delay();
000048  f7fffffe          BL       AD7689_Delay
;;;211    	return AD7689_Data;
00004c  f8bd0000          LDRH     r0,[sp,#0]
;;;212    }
000050  b004              ADD      sp,sp,#0x10
000052  bd10              POP      {r4,pc}
;;;213    
                          ENDP

                  |L9.84|
                          DCD      0x40020400

                          AREA ||i.dma_rec||, CODE, READONLY, ALIGN=2

                  dma_rec PROC
;;;179    //DMA接收
;;;180    void dma_rec(vu16 buf,u16 ndtr)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;181    {
000002  b086              SUB      sp,sp,#0x18
000004  460c              MOV      r4,r1
;;;182    	SPI_InitTypeDef  SPI_InitStructure;
;;;183    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_RxOnly;
000006  f44f6080          MOV      r0,#0x400
00000a  f8ad0004          STRH     r0,[sp,#4]
;;;184    	SPI_Init(SPI1, &SPI_InitStructure);//只读
00000e  4e1c              LDR      r6,|L10.128|
000010  a901              ADD      r1,sp,#4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SPI_Init
;;;185    	DMA_Cmd(DMA2_Stream0,DISABLE);
000018  4d1a              LDR      r5,|L10.132|
00001a  2100              MOVS     r1,#0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       DMA_Cmd
                  |L10.34|
;;;186    	while (DMA_GetCmdStatus(DMA2_Stream0) != DISABLE){}//等待DMA可配置
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DMA_GetCmdStatus
000028  2800              CMP      r0,#0
00002a  d1fa              BNE      |L10.34|
;;;187    	DMA2_Stream0->NDTR=ndtr;
00002c  4815              LDR      r0,|L10.132|
00002e  1d00              ADDS     r0,r0,#4
000030  6004              STR      r4,[r0,#0]
;;;188    	DMA2_Stream0->M0AR=(u32)buf;
000032  f8bd0018          LDRH     r0,[sp,#0x18]
000036  4913              LDR      r1,|L10.132|
000038  310c              ADDS     r1,r1,#0xc
00003a  6008              STR      r0,[r1,#0]
;;;189    	DMA_ClearFlag(DMA2_Stream0,DMA_FLAG_TCIF0|DMA_FLAG_HTIF0|DMA_FLAG_TEIF0|DMA_FLAG_DMEIF0|DMA_FLAG_FEIF0);
00003c  4912              LDR      r1,|L10.136|
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       DMA_ClearFlag
;;;190    	SPI1->DR;
000044  89b0              LDRH     r0,[r6,#0xc]
000046  4634              MOV      r4,r6
;;;191    	DMA_Cmd(DMA2_Stream0,ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       DMA_Cmd
;;;192    	while(!DMA_GetFlagStatus(DMA2_Stream0,DMA_FLAG_TCIF0));
000050  4e0e              LDR      r6,|L10.140|
                  |L10.82|
000052  4628              MOV      r0,r5
000054  4631              MOV      r1,r6
000056  f7fffffe          BL       DMA_GetFlagStatus
00005a  2800              CMP      r0,#0
00005c  d0f9              BEQ      |L10.82|
;;;193    	DMA_Cmd(DMA2_Stream0,DISABLE);
00005e  2100              MOVS     r1,#0
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       DMA_Cmd
;;;194    	DMA_ClearFlag(DMA2_Stream0,DMA_FLAG_TCIF0);
000066  4631              MOV      r1,r6
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       DMA_ClearFlag
;;;195    		
;;;196    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
00006e  2000              MOVS     r0,#0
000070  f8ad0004          STRH     r0,[sp,#4]
;;;197    	SPI_Init(SPI1, &SPI_InitStructure);//恢复双全工
000074  a901              ADD      r1,sp,#4
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       SPI_Init
;;;198    }
00007c  b008              ADD      sp,sp,#0x20
00007e  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP

                  |L10.128|
                          DCD      0x40013000
                  |L10.132|
                          DCD      0x40026410
                  |L10.136|
                          DCD      0x1080003d
                  |L10.140|
                          DCD      0x10000020

                          AREA ||i.dma_send||, CODE, READONLY, ALIGN=2

                  dma_send PROC
;;;165    //DMA发送
;;;166    void dma_send(vu16 buf,u16 ndtr)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;167    {
000002  460c              MOV      r4,r1
;;;168    	DMA_Cmd(DMA2_Stream3,DISABLE);
000004  4d17              LDR      r5,|L11.100|
000006  2100              MOVS     r1,#0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       DMA_Cmd
                  |L11.14|
;;;169    	while (DMA_GetCmdStatus(DMA2_Stream3) != DISABLE){}//等待DMA可配置
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       DMA_GetCmdStatus
000014  2800              CMP      r0,#0
000016  d1fa              BNE      |L11.14|
;;;170    	DMA2_Stream3->NDTR=ndtr;
000018  4812              LDR      r0,|L11.100|
00001a  1d00              ADDS     r0,r0,#4
00001c  6004              STR      r4,[r0,#0]
;;;171    	DMA2_Stream3->M0AR=(u32)buf;
00001e  f8bd0000          LDRH     r0,[sp,#0]
000022  4910              LDR      r1,|L11.100|
000024  310c              ADDS     r1,r1,#0xc
000026  6008              STR      r0,[r1,#0]
;;;172    	DMA_ClearFlag(DMA2_Stream3,DMA_FLAG_TCIF3|DMA_FLAG_HTIF3|DMA_FLAG_TEIF3|DMA_FLAG_DMEIF3|DMA_FLAG_FEIF3);
000028  462c              MOV      r4,r5
00002a  f04f51fa          MOV      r1,#0x1f400000
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       DMA_ClearFlag
;;;173    	SPI1->DR;
000034  490c              LDR      r1,|L11.104|
000036  8988              LDRH     r0,[r1,#0xc]
;;;174    	DMA_Cmd(DMA2_Stream3,ENABLE);
000038  2101              MOVS     r1,#1
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       DMA_Cmd
;;;175    	while(!DMA_GetFlagStatus(DMA2_Stream3,DMA_FLAG_TCIF3));
000040  f04f55c0          MOV      r5,#0x18000000
                  |L11.68|
000044  4629              MOV      r1,r5
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       DMA_GetFlagStatus
00004c  2800              CMP      r0,#0
00004e  d0f9              BEQ      |L11.68|
;;;176    	DMA_Cmd(DMA2_Stream3,DISABLE);
000050  2100              MOVS     r1,#0
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       DMA_Cmd
;;;177    	DMA_ClearFlag(DMA2_Stream3,DMA_FLAG_TCIF3);
000058  4629              MOV      r1,r5
00005a  4620              MOV      r0,r4
00005c  e8bd407c          POP      {r2-r6,lr}
000060  f7ffbffe          B.W      DMA_ClearFlag
;;;178    }
;;;179    //DMA接收
                          ENDP

                  |L11.100|
                          DCD      0x40026458
                  |L11.104|
                          DCD      0x40013000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AD7689_Buffer
                          %        16
                  Ad7689_Fit_Imon
                          %        120
                  Ad7689_Fit_Imon1
                          %        100
                  Ad7689_Fit_Vmon
                          %        200
                  Ad7689_Fit_Rmon
                          %        60
                  Ad7689_Fit_PVmon
                          %        200

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.bss||
                  DMA_Buffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  I_cont
000000  00                DCB      0x00
                  I1_cont
000001  00                DCB      0x00
                  V_cont
000002  00                DCB      0x00
                  R_cont
000003  00                DCB      0x00
                  V1_cont
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AD7689.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REV16|
#line 129 "E:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD7689_c_5bab55e0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REVSH|
#line 144
|__asm___8_AD7689_c_5bab55e0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
